<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/dominictarr/event-stream"

    >event-stream (v3.3.4)</a>
</h1>
<h4>construct pipes of streams of events</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.event-stream">module event-stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.Stream">
            function <span class="apidocSignatureSpan">event-stream.</span>Stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.child">
            function <span class="apidocSignatureSpan">event-stream.</span>child
            <span class="apidocSignatureSpan">(child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.concat">
            function <span class="apidocSignatureSpan">event-stream.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.connect">
            function <span class="apidocSignatureSpan">event-stream.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.duplex">
            function <span class="apidocSignatureSpan">event-stream.</span>duplex
            <span class="apidocSignatureSpan">(writer, reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.from">
            function <span class="apidocSignatureSpan">event-stream.</span>from
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.join">
            function <span class="apidocSignatureSpan">event-stream.</span>join
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.log">
            function <span class="apidocSignatureSpan">event-stream.</span>log
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.map">
            function <span class="apidocSignatureSpan">event-stream.</span>map
            <span class="apidocSignatureSpan">(mapper, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.mapSync">
            function <span class="apidocSignatureSpan">event-stream.</span>mapSync
            <span class="apidocSignatureSpan">(sync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.merge">
            function <span class="apidocSignatureSpan">event-stream.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.parse">
            function <span class="apidocSignatureSpan">event-stream.</span>parse
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.pause">
            function <span class="apidocSignatureSpan">event-stream.</span>pause
            <span class="apidocSignatureSpan">(write, end, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.pipe">
            function <span class="apidocSignatureSpan">event-stream.</span>pipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.pipeable">
            function <span class="apidocSignatureSpan">event-stream.</span>pipeable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.pipeline">
            function <span class="apidocSignatureSpan">event-stream.</span>pipeline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.readArray">
            function <span class="apidocSignatureSpan">event-stream.</span>readArray
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.readable">
            function <span class="apidocSignatureSpan">event-stream.</span>readable
            <span class="apidocSignatureSpan">(func, continueOnError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.replace">
            function <span class="apidocSignatureSpan">event-stream.</span>replace
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.split">
            function <span class="apidocSignatureSpan">event-stream.</span>split
            <span class="apidocSignatureSpan">(matcher, mapper, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.stringify">
            function <span class="apidocSignatureSpan">event-stream.</span>stringify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.through">
            function <span class="apidocSignatureSpan">event-stream.</span>through
            <span class="apidocSignatureSpan">(write, end, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.wait">
            function <span class="apidocSignatureSpan">event-stream.</span>wait
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.writeArray">
            function <span class="apidocSignatureSpan">event-stream.</span>writeArray
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">event-stream.</span>index</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.event-stream.index">module event-stream.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.Stream">
            function <span class="apidocSignatureSpan">event-stream.index.</span>Stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.child">
            function <span class="apidocSignatureSpan">event-stream.index.</span>child
            <span class="apidocSignatureSpan">(child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.concat">
            function <span class="apidocSignatureSpan">event-stream.index.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.connect">
            function <span class="apidocSignatureSpan">event-stream.index.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.duplex">
            function <span class="apidocSignatureSpan">event-stream.index.</span>duplex
            <span class="apidocSignatureSpan">(writer, reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.from">
            function <span class="apidocSignatureSpan">event-stream.index.</span>from
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.join">
            function <span class="apidocSignatureSpan">event-stream.index.</span>join
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.log">
            function <span class="apidocSignatureSpan">event-stream.index.</span>log
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.map">
            function <span class="apidocSignatureSpan">event-stream.index.</span>map
            <span class="apidocSignatureSpan">(mapper, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.mapSync">
            function <span class="apidocSignatureSpan">event-stream.index.</span>mapSync
            <span class="apidocSignatureSpan">(sync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.merge">
            function <span class="apidocSignatureSpan">event-stream.index.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.parse">
            function <span class="apidocSignatureSpan">event-stream.index.</span>parse
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.pause">
            function <span class="apidocSignatureSpan">event-stream.index.</span>pause
            <span class="apidocSignatureSpan">(write, end, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.pipe">
            function <span class="apidocSignatureSpan">event-stream.index.</span>pipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.pipeable">
            function <span class="apidocSignatureSpan">event-stream.index.</span>pipeable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.pipeline">
            function <span class="apidocSignatureSpan">event-stream.index.</span>pipeline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.readArray">
            function <span class="apidocSignatureSpan">event-stream.index.</span>readArray
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.readable">
            function <span class="apidocSignatureSpan">event-stream.index.</span>readable
            <span class="apidocSignatureSpan">(func, continueOnError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.replace">
            function <span class="apidocSignatureSpan">event-stream.index.</span>replace
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.split">
            function <span class="apidocSignatureSpan">event-stream.index.</span>split
            <span class="apidocSignatureSpan">(matcher, mapper, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.stringify">
            function <span class="apidocSignatureSpan">event-stream.index.</span>stringify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.through">
            function <span class="apidocSignatureSpan">event-stream.index.</span>through
            <span class="apidocSignatureSpan">(write, end, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.wait">
            function <span class="apidocSignatureSpan">event-stream.index.</span>wait
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.index.writeArray">
            function <span class="apidocSignatureSpan">event-stream.index.</span>writeArray
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.event-stream.through">module event-stream.through</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.through.through">
            function <span class="apidocSignatureSpan">event-stream.</span>through
            <span class="apidocSignatureSpan">(write, end, opts)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.event-stream" id="apidoc.module.event-stream">module event-stream</a></h1>


    <h2>
        <a href="#apidoc.element.event-stream.Stream" id="apidoc.element.event-stream.Stream">
        function <span class="apidocSignatureSpan">event-stream.</span>Stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.child" id="apidoc.element.event-stream.child">
        function <span class="apidocSignatureSpan">event-stream.</span>child
        <span class="apidocSignatureSpan">(child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">child = function (child) {

  return es.duplex(child.stdin, child.stdout)

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## child (child_process)

Create a through stream from a child process ...

``` js
  var cp = require(&#x27;child_process&#x27;)

  es.<span class="apidocCodeKeywordSpan">child</span>(cp.exec(&#x27;grep Stream&#x27;)) // a through stream

```

## wait (callback)

waits for stream to emit &#x27;end&#x27;.
joins chunks of a stream into a single string or buffer.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.concat" id="apidoc.element.event-stream.concat">
        function <span class="apidocSignatureSpan">event-stream.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function () {
  var toMerge = [].slice.call(arguments)
  if (toMerge.length === 1 &#x26;&#x26; (toMerge[0] instanceof Array)) {
    toMerge = toMerge[0] //handle array as arguments object
  }
  var stream = new Stream()
  stream.setMaxListeners(0) // allow adding more than 11 streams
  var endCount = 0
  stream.writable = stream.readable = true

  if (toMerge.length) {
    toMerge.forEach(function (e) {
      e.pipe(stream, {end: false})
      var ended = false
      e.on(&#x27;end&#x27;, function () {
        if(ended) return
        ended = true
        endCount ++
        if(endCount == toMerge.length)
          stream.emit(&#x27;end&#x27;)
      })
    })
  } else {
    process.nextTick(function () {
      stream.emit(&#x27;end&#x27;)
    })
  }

  stream.write = function (data) {
    this.emit(&#x27;data&#x27;, data)
  }
  stream.destroy = function () {
    toMerge.forEach(function (e) {
      if(e.destroy) e.destroy()
    })
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// wait. callback when &#x27;end&#x27; is emitted, with all chunks appended as string.
//

es.wait = function (callback) {
  var arr = []
  return es.through(function (data) { arr.push(data) },
    function () {
      var body = Buffer.isBuffer(arr[0]) ? Buffer.<span class="apidocCodeKeywordSpan">concat</span>(arr)
        : arr.join(&#x27;&#x27;)
      this.emit(&#x27;data&#x27;, body)
      this.emit(&#x27;end&#x27;)
      if(callback) callback(null, body)
    })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.connect" id="apidoc.element.event-stream.connect">
        function <span class="apidocSignatureSpan">event-stream.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {

  var streams = [].slice.call(arguments)
    , first = streams[0]
    , last = streams[streams.length - 1]
    , thepipe = duplexer(first, last)

  if(streams.length == 1)
    return streams[0]
  else if (!streams.length)
    throw new Error(&#x27;connect called with empty args&#x27;)

  //pipe all the streams together

  function recurse (streams) {
    if(streams.length &#x3c; 2)
      return
    streams[0].pipe(streams[1])
    recurse(streams.slice(1))
  }

  recurse(streams)

  function onerror () {
    var args = [].slice.call(arguments)
    args.unshift(&#x27;error&#x27;)
    thepipe.emit.apply(thepipe, args)
  }

  //es.duplex already reemits the error from the first and last stream.
  //add a listener for the inner streams in the pipeline.
  for(var i = 1; i &#x3c; streams.length - 1; i ++)
    streams[i].on(&#x27;error&#x27;, onerror)

  return thepipe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var es = require(&#x27;../&#x27;)
, it = require(&#x27;it-is&#x27;).style(&#x27;colour&#x27;)
, d = require(&#x27;ubelt&#x27;)

function makeExamplePipe() {

return es.<span class="apidocCodeKeywordSpan">connect</span>(
  es.map(function (data, callback) {
    callback(null, data * 2)
  }),
  es.map(function (data, callback) {
    d.delay(callback)(null, data)
  }),
  es.map(function (data, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.duplex" id="apidoc.element.event-stream.duplex">
        function <span class="apidocSignatureSpan">event-stream.</span>duplex
        <span class="apidocSignatureSpan">(writer, reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function duplex(writer, reader) {
    var stream = new Stream()
    var ended = false

    forEach(writeMethods, proxyWriter)

    forEach(readMethods, proxyReader)

    forEach(readEvents, proxyStream)

    reader.on(&#x22;end&#x22;, handleEnd)

    writer.on(&#x22;drain&#x22;, function() {
      stream.emit(&#x22;drain&#x22;)
    })

    writer.on(&#x22;error&#x22;, reemit)
    reader.on(&#x22;error&#x22;, reemit)

    stream.writable = writer.writable
    stream.readable = reader.readable

    return stream

    function proxyWriter(methodName) {
        stream[methodName] = method

        function method() {
            return writer[methodName].apply(writer, arguments)
        }
    }

    function proxyReader(methodName) {
        stream[methodName] = method

        function method() {
            stream.emit(methodName)
            var func = reader[methodName]
            if (func) {
                return func.apply(reader, arguments)
            }
            reader.emit(methodName)
        }
    }

    function proxyStream(methodName) {
        reader.on(methodName, reemit)

        function reemit() {
            var args = slice.call(arguments)
            args.unshift(methodName)
            stream.emit.apply(stream, args)
        }
    }

    function handleEnd() {
        if (ended) {
            return
        }
        ended = true
        var args = slice.call(arguments)
        args.unshift(&#x22;end&#x22;)
        stream.emit.apply(stream, args)
    }

    function reemit(err) {
        stream.emit(&#x22;error&#x22;, err)
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// child -- pipe through a child process
//

es.child = function (child) {

  return es.<span class="apidocCodeKeywordSpan">duplex</span>(child.stdin, child.stdout)

}

//
// parse
//
// must be used after es.split() to ensure that each chunk represents a line
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.from" id="apidoc.element.event-stream.from">
        function <span class="apidocSignatureSpan">event-stream.</span>from
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function from(source) {
  if(Array.isArray(source)) {
		var source_index = 0, source_len = source.length;
    return from (function (i) {
      if(source_index &#x3c; source_len)
        this.emit(&#x27;data&#x27;, source[source_index++])
      else
        this.emit(&#x27;end&#x27;)
      return true
    })
  }
  var s = new Stream(), i = 0
  s.ended = false
  s.started = false
  s.readable = true
  s.writable = false
  s.paused = false
  s.ended = false
  s.pause = function () {
    s.started = true
    s.paused = true
  }
  function next () {
    s.started = true
    if(s.ended) return
    while(!s.ended &#x26;&#x26; !s.paused &#x26;&#x26; source.call(s, i++, function () {
      if(!s.ended &#x26;&#x26; !s.paused)
          process.nextTick(next);
    }))
      ;
  }
  s.resume = function () {
    s.started = true
    s.paused = false
    next()
  }
  s.on(&#x27;end&#x27;, function () {
    s.ended = true
    s.readable = false
    process.nextTick(s.destroy)
  })
  s.destroy = function () {
    s.ended = true
    s.emit(&#x27;close&#x27;)
  }
<span class="apidocCodeCommentSpan">  /*
    by default, the stream will start emitting at nextTick
    if you want, you can pause it, after pipeing.
    you can also resume before next tick, and that will also
    work.
  */
</span>  process.nextTick(function () {
    if(!s.started) s.resume()
  })
  return s
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.join" id="apidoc.element.event-stream.join">
        function <span class="apidocSignatureSpan">event-stream.</span>join
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (str) {

  //legacy api
  if(&#x27;function&#x27; === typeof str)
    return es.wait(str)

  var first = true
  return es.through(function (data) {
    if(!first)
      this.emit(&#x27;data&#x27;, str)
    first = false
    this.emit(&#x27;data&#x27;, data)
    return true
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + &#x27;\n&#x27;
  })
}

//
// replace a string within a stream.
//
// warn: just concatenates the string and then does str.split().<span class="apidocCodeKeywordSpan">join</span>().
// probably not optimal.
// for smallish responses, who cares?
// I need this for shadow-npm so it&#x27;s only relatively small json files.

es.replace = function (from, to) {
  return es.pipeline(es.split(from), es.join(to))
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.log" id="apidoc.element.event-stream.log">
        function <span class="apidocSignatureSpan">event-stream.</span>log
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (name) {
  return es.through(function (data) {
    var args = [].slice.call(arguments)
    if(name) console.error(name, data)
    else     console.error(data)
    this.emit(&#x27;data&#x27;, data)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a single data event with the reduced value once the input stream ends.

``` js
var reduce = require(&#x22;stream-reduce&#x22;);
process.stdin.pipe(reduce(function(acc, data) {
  return acc + data.length;
}, 0)).on(&#x22;data&#x22;, function(length) {
  console.<span class="apidocCodeKeywordSpan">log</span>(&#x22;stdin size:&#x22;, length);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.map" id="apidoc.element.event-stream.map">
        function <span class="apidocSignatureSpan">event-stream.</span>map
        <span class="apidocSignatureSpan">(mapper, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (mapper, opts) {

  var stream = new Stream()
    , self = this
    , inputs = 0
    , outputs = 0
    , ended = false
    , paused = false
    , destroyed = false
    , lastWritten = 0
    , inNext = false

  this.opts = opts || {};
  var errorEventName = this.opts.failures ? &#x27;failure&#x27; : &#x27;error&#x27;;

  // Items that are not ready to be written yet (because they would come out of
  // order) get stuck in a queue for later.
  var writeQueue = {}

  stream.writable = true
  stream.readable = true

  function queueData (data, number) {
    var nextToWrite = lastWritten + 1

    if (number === nextToWrite) {
      // If it&#x27;s next, and its not undefined write it
      if (data !== undefined) {
        stream.emit.apply(stream, [&#x27;data&#x27;, data])
      }
      lastWritten ++
      nextToWrite ++
    } else {
      // Otherwise queue it for later.
      writeQueue[number] = data
    }

    // If the next value is in the queue, write it
    if (writeQueue.hasOwnProperty(nextToWrite)) {
      var dataToWrite = writeQueue[nextToWrite]
      delete writeQueue[nextToWrite]
      return queueData(dataToWrite, nextToWrite)
    }

    outputs ++
    if(inputs === outputs) {
      if(paused) paused = false, stream.emit(&#x27;drain&#x27;) //written all the incoming events
      if(ended) end()
    }
  }

  function next (err, data, number) {
    if(destroyed) return
    inNext = true

    if (!err || self.opts.failures) {
      queueData(data, number)
    }

    if (err) {
      stream.emit.apply(stream, [ errorEventName, err ]);
    }

    inNext = false;
  }

  // Wrap the mapper function by calling its callback with the order number of
  // the item in the stream.
  function wrappedMapper (input, number, callback) {
    return mapper.call(null, input, function(err, data){
      callback(err, data, number)
    })
  }

  stream.write = function (data) {
    if(ended) throw new Error(&#x27;map stream is not writable&#x27;)
    inNext = false
    inputs ++

    try {
      //catch sync errors and handle them like async errors
      var written = wrappedMapper(data, inputs, next)
      paused = (written === false)
      return !paused
    } catch (err) {
      //if the callback has been called syncronously, and the error
      //has occured in an listener, throw it again.
      if(inNext)
        throw err
      next(err)
      return !paused
    }
  }

  function end (data) {
    //if end was called with args, write it,
    ended = true //write will emit &#x27;end&#x27; if ended is true
    stream.writable = false
    if(data !== undefined) {
      return queueData(data, inputs)
    } else if (inputs == outputs) { //wait for processing
      stream.readable = false, stream.emit(&#x27;end&#x27;), stream.destroy()
    }
  }

  stream.end = function (data) {
    if(ended) return
    end()
  }

  stream.destroy = function () {
    ended = destroyed = true
    stream.writable = stream.readable = paused = false
    process.nextTick(function () {
      stream.emit(&#x27;close&#x27;)
    })
  }
  stream.pause = function () {
    paused = true
  }

  stream.resume = function () {
    paused = false
  }

  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!module.parent) {
  var es = require(&#x27;event-stream&#x27;)
  var inspect = require(&#x27;util&#x27;).inspect

  process.stdin                        //connect streams together with `pipe`
    .pipe(es.split())                  //split stream to break on newlines
    .pipe(es.<span class="apidocCodeKeywordSpan">map</span>(function (data, cb) { //turn this async function into a stream
      cb(null
        , inspect(JSON.parse(data)))   //render it nicely
    }))
    .pipe(process.stdout)              // pipe it to stdout !
}
```
run it ...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.mapSync" id="apidoc.element.event-stream.mapSync">
        function <span class="apidocSignatureSpan">event-stream.</span>mapSync
        <span class="apidocSignatureSpan">(sync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapSync = function (sync) {
  return es.through(function write(data) {
    var mappedData
    try {
      mappedData = sync(data)
    } catch (err) {
      return this.emit(&#x27;error&#x27;, err)
    }
    if (mappedData !== undefined)
      this.emit(&#x27;data&#x27;, mappedData)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
//
// stringify
//

es.stringify = function () {
  var Buffer = require(&#x27;buffer&#x27;).Buffer
  return es.<span class="apidocCodeKeywordSpan">mapSync</span>(function (e){
    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + &#x27;\n&#x27;
  })
}

//
// replace a string within a stream.
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.merge" id="apidoc.element.event-stream.merge">
        function <span class="apidocSignatureSpan">event-stream.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function () {
  var toMerge = [].slice.call(arguments)
  if (toMerge.length === 1 &#x26;&#x26; (toMerge[0] instanceof Array)) {
    toMerge = toMerge[0] //handle array as arguments object
  }
  var stream = new Stream()
  stream.setMaxListeners(0) // allow adding more than 11 streams
  var endCount = 0
  stream.writable = stream.readable = true

  if (toMerge.length) {
    toMerge.forEach(function (e) {
      e.pipe(stream, {end: false})
      var ended = false
      e.on(&#x27;end&#x27;, function () {
        if(ended) return
        ended = true
        endCount ++
        if(endCount == toMerge.length)
          stream.emit(&#x27;end&#x27;)
      })
    })
  } else {
    process.nextTick(function () {
      stream.emit(&#x27;end&#x27;)
    })
  }

  stream.write = function (data) {
    this.emit(&#x27;data&#x27;, data)
  }
  stream.destroy = function () {
    toMerge.forEach(function (e) {
      if(e.destroy) e.destroy()
    })
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3e; concat â†’ merge

Merges streams into one and returns it.
Incoming data will be emitted as soon it comes into - no ordering will be applied (for example: `data1 data1 data2 data1 data2` -
where `data1` and `data2` is data from two streams).
Counts how many streams were passed to it and emits end only when all streams emitted end.

```js
es.<span class="apidocCodeKeywordSpan">merge</span>(
  process.stdout,
  process.stderr
).pipe(fs.createWriteStream(&#x27;output.log&#x27;));
```

It can also take an Array of streams as input like this:
```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.parse" id="apidoc.element.event-stream.parse">
        function <span class="apidocSignatureSpan">event-stream.</span>parse
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (options) {
  var emitError = !!(options ? options.error : false)
  return es.through(function (data) {
    var obj
    try {
      if(data) //ignore empty lines
        obj = JSON.parse(data.toString())
    } catch (err) {
      if (emitError)
        return this.emit(&#x27;error&#x27;, err)
      return console.error(err, &#x27;attempting to parse:&#x27;, data)
    }
    //ignore lines that where only whitespace.
    if(obj !== undefined)
      this.emit(&#x27;data&#x27;, obj)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

}

//
// parse
//
// must be used after es.split() to ensure that each chunk represents a line
// source.pipe(es.split()).pipe(es.<span class="apidocCodeKeywordSpan">parse</span>())

es.parse = function (options) {
var emitError = !!(options ? options.error : false)
return es.through(function (data) {
  var obj
  try {
    if(data) //ignore empty lines
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.pause" id="apidoc.element.event-stream.pause">
        function <span class="apidocSignatureSpan">event-stream.</span>pause
        <span class="apidocSignatureSpan">(write, end, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function through(write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts &#x26;&#x26; opts.autoPause   === false)
  stream.autoDestroy = !(opts &#x26;&#x26; opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length &#x26;&#x26; !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit(&#x27;end&#x27;)
      else
        stream.emit(&#x27;data&#x27;, data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first &#x27;end&#x27; listener
  //must call destroy next tick, to make sure we&#x27;re after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for &#x27;end&#x27;

  stream.on(&#x27;end&#x27;, function () {
    stream.readable = false
    if(!stream.writable &#x26;&#x26; stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable &#x26;&#x26; stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit(&#x27;close&#x27;)
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit(&#x27;resume&#x27;)
    }
    drain()
    //may have become paused again,
    //as drain emits &#x27;data&#x27;.
    if(!stream.paused)
      stream.emit(&#x27;drain&#x27;)
    return stream
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

[node Stream documentation](http://nodejs.org/api/stream.html)

## through (write?, end?)

Re-emits data synchronously. Easy way to create synchronous through streams.
Pass in optional `write` and `end` methods. They will be called in the
context of the stream. Use `this.<span class="apidocCodeKeywordSpan">pause</span>()` and `this.resume()` to manage flow.
Check `this.paused` to see current flow state. (write always returns `!this.paused`)

this function is the basis for most of the synchronous streams in `event-stream`.

``` js

es.through(function write(data) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.pipe" id="apidoc.element.event-stream.pipe">
        function <span class="apidocSignatureSpan">event-stream.</span>pipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function () {

  var streams = [].slice.call(arguments)
    , first = streams[0]
    , last = streams[streams.length - 1]
    , thepipe = duplexer(first, last)

  if(streams.length == 1)
    return streams[0]
  else if (!streams.length)
    throw new Error(&#x27;connect called with empty args&#x27;)

  //pipe all the streams together

  function recurse (streams) {
    if(streams.length &#x3c; 2)
      return
    streams[0].pipe(streams[1])
    recurse(streams.slice(1))
  }

  recurse(streams)

  function onerror () {
    var args = [].slice.call(arguments)
    args.unshift(&#x27;error&#x27;)
    thepipe.emit.apply(thepipe, args)
  }

  //es.duplex already reemits the error from the first and last stream.
  //add a listener for the inner streams in the pipeline.
  for(var i = 1; i &#x3c; streams.length - 1; i ++)
    streams[i].on(&#x27;error&#x27;, onerror)

  return thepipe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var stream = new Stream()
stream.setMaxListeners(0) // allow adding more than 11 streams
var endCount = 0
stream.writable = stream.readable = true

if (toMerge.length) {
  toMerge.forEach(function (e) {
    e.<span class="apidocCodeKeywordSpan">pipe</span>(stream, {end: false})
    var ended = false
    e.on(&#x27;end&#x27;, function () {
      if(ended) return
      ended = true
      endCount ++
      if(endCount == toMerge.length)
        stream.emit(&#x27;end&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.pipeable" id="apidoc.element.event-stream.pipeable">
        function <span class="apidocSignatureSpan">event-stream.</span>pipeable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipeable = function () {
  throw new Error(&#x27;[EVENT-STREAM] es.pipeable is deprecated&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.pipeline" id="apidoc.element.event-stream.pipeline">
        function <span class="apidocSignatureSpan">event-stream.</span>pipeline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipeline = function () {

  var streams = [].slice.call(arguments)
    , first = streams[0]
    , last = streams[streams.length - 1]
    , thepipe = duplexer(first, last)

  if(streams.length == 1)
    return streams[0]
  else if (!streams.length)
    throw new Error(&#x27;connect called with empty args&#x27;)

  //pipe all the streams together

  function recurse (streams) {
    if(streams.length &#x3c; 2)
      return
    streams[0].pipe(streams[1])
    recurse(streams.slice(1))
  }

  recurse(streams)

  function onerror () {
    var args = [].slice.call(arguments)
    args.unshift(&#x27;error&#x27;)
    thepipe.emit.apply(thepipe, args)
  }

  //es.duplex already reemits the error from the first and last stream.
  //add a listener for the inner streams in the pipeline.
  for(var i = 1; i &#x3c; streams.length - 1; i ++)
    streams[i].on(&#x27;error&#x27;, onerror)

  return thepipe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// warn: just concatenates the string and then does str.split().join().
// probably not optimal.
// for smallish responses, who cares?
// I need this for shadow-npm so it&#x27;s only relatively small json files.

es.replace = function (from, to) {
  return es.<span class="apidocCodeKeywordSpan">pipeline</span>(es.split(from), es.join(to))
}

//
// join chunks with a joiner. just like Array#join
// also accepts a callback that is passed the chunks appended together
// this is still supported for legacy reasons.
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.readArray" id="apidoc.element.event-stream.readArray">
        function <span class="apidocSignatureSpan">event-stream.</span>readArray
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArray = function (array) {
  var stream = new Stream()
    , i = 0
    , paused = false
    , ended = false

  stream.readable = true
  stream.writable = false

  if(!Array.isArray(array))
    throw new Error(&#x27;event-stream.read expects an array&#x27;)

  stream.resume = function () {
    if(ended) return
    paused = false
    var l = array.length
    while(i &#x3c; l &#x26;&#x26; !paused &#x26;&#x26; !ended) {
      stream.emit(&#x27;data&#x27;, array[i++])
    }
    if(i == l &#x26;&#x26; !ended)
      ended = true, stream.readable = false, stream.emit(&#x27;end&#x27;)
  }
  process.nextTick(stream.resume)
  stream.pause = function () {
     paused = true
  }
  stream.destroy = function () {
    ended = true
    stream.emit(&#x27;close&#x27;)
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Create a readable stream from an Array.

Just emit each item as a data event, respecting `pause` and `resume`.

``` js
  var es = require(&#x27;event-stream&#x27;)
    , reader = es.<span class="apidocCodeKeywordSpan">readArray</span>([1,2,3])

  reader.pipe(...)
```

If you want the stream behave like a 0.10 stream you will need to wrap it using [`Readable.wrap()`](http://nodejs.org/api/stream
.html#stream_readable_wrap_stream) function. Example:

``` js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.readable" id="apidoc.element.event-stream.readable">
        function <span class="apidocSignatureSpan">event-stream.</span>readable
        <span class="apidocSignatureSpan">(func, continueOnError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readable = function (func, continueOnError) {
  var stream = new Stream()
    , i = 0
    , paused = false
    , ended = false
    , reading = false

  stream.readable = true
  stream.writable = false

  if(&#x27;function&#x27; !== typeof func)
    throw new Error(&#x27;event-stream.readable expects async function&#x27;)

  stream.on(&#x27;end&#x27;, function () { ended = true })

  function get (err, data) {

    if(err) {
      stream.emit(&#x27;error&#x27;, err)
      if(!continueOnError) stream.emit(&#x27;end&#x27;)
    } else if (arguments.length &#x3e; 1)
      stream.emit(&#x27;data&#x27;, data)

    immediately(function () {
      if(ended || paused || reading) return
      try {
        reading = true
        func.call(stream, i++, function () {
          reading = false
          get.apply(null, arguments)
        })
      } catch (err) {
        stream.emit(&#x27;error&#x27;, err)
      }
    })
  }
  stream.resume = function () {
    paused = false
    get()
  }
  process.nextTick(get)
  stream.pause = function () {
     paused = true
  }
  stream.destroy = function () {
    stream.emit(&#x27;end&#x27;)
    stream.emit(&#x27;close&#x27;)
    ended = true
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
create a readable stream (that respects pause) from an async function.
while the stream is not paused,
the function will be polled with `(count, callback)`,
and `this`  will be the readable stream.

``` js

es.<span class="apidocCodeKeywordSpan">readable</span>(function (count, callback) {
if(streamHasEnded)
  return this.emit(&#x27;end&#x27;)

//...

this.emit(&#x27;data&#x27;, data) //use this way to emit multiple chunks per call.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.replace" id="apidoc.element.event-stream.replace">
        function <span class="apidocSignatureSpan">event-stream.</span>replace
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (from, to) {
  return es.pipeline(es.split(from), es.join(to))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
reader.pipe(join)

}


exports [&#x27;fizz buzz replace&#x27;] = function (test) {
var split = es.split(/(1)/)
var replace = es.<span class="apidocCodeKeywordSpan">replace</span>(&#x27;7&#x27;, &#x27;seven&#x27;)
//  var x = spec(replace).through()
split
  .pipe(replace)
  .pipe(es.join(function (err, string) {
    it(string).equal(fizz7buzz)
  }))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.split" id="apidoc.element.event-stream.split">
        function <span class="apidocSignatureSpan">event-stream.</span>split
        <span class="apidocSignatureSpan">(matcher, mapper, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function split(matcher, mapper, options) {
  var decoder = new Decoder()
  var soFar = &#x27;&#x27;
  var maxLength = options &#x26;&#x26; options.maxLength;
  if(&#x27;function&#x27; === typeof matcher)
    mapper = matcher, matcher = null
  if (!matcher)
    matcher = /\r?\n/

  function emit(stream, piece) {
    if(mapper) {
      try {
        piece = mapper(piece)
      }
      catch (err) {
        return stream.emit(&#x27;error&#x27;, err)
      }
      if(&#x27;undefined&#x27; !== typeof piece)
        stream.queue(piece)
    }
    else
      stream.queue(piece)
  }

  function next (stream, buffer) {
    var pieces = ((soFar != null ? soFar : &#x27;&#x27;) + buffer).split(matcher)
    soFar = pieces.pop()

    if (maxLength &#x26;&#x26; soFar.length &#x3e; maxLength)
      stream.emit(&#x27;error&#x27;, new Error(&#x27;maximum buffer reached&#x27;))

    for (var i = 0; i &#x3c; pieces.length; i++) {
      var piece = pieces[i]
      emit(stream, piece)
    }
  }

  return through(function (b) {
    next(this, decoder.write(b))
  },
  function () {
    if(decoder.end)
      next(this, decoder.end())
    if(soFar != null)
      emit(this, soFar)
    this.queue(null)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return es.duplex(child.stdin, child.stdout)

}

//
// parse
//
// must be used after es.<span class="apidocCodeKeywordSpan">split</span>() to ensure that each chunk represents a line
// source.pipe(es.split()).pipe(es.parse())

es.parse = function (options) {
var emitError = !!(options ? options.error : false)
return es.through(function (data) {
  var obj
  try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.stringify" id="apidoc.element.event-stream.stringify">
        function <span class="apidocSignatureSpan">event-stream.</span>stringify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function () {
  var Buffer = require(&#x27;buffer&#x27;).Buffer
  return es.mapSync(function (e){
    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + &#x27;\n&#x27;
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// stringify
//

es.stringify = function () {
  var Buffer = require(&#x27;buffer&#x27;).Buffer
  return es.mapSync(function (e){
    return JSON.<span class="apidocCodeKeywordSpan">stringify</span>(Buffer.isBuffer(e) ? e.toString() : e) + &#x27;\n&#x27;
  })
}

//
// replace a string within a stream.
//
// warn: just concatenates the string and then does str.split().join().
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.through" id="apidoc.element.event-stream.through">
        function <span class="apidocSignatureSpan">event-stream.</span>through
        <span class="apidocSignatureSpan">(write, end, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function through(write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts &#x26;&#x26; opts.autoPause   === false)
  stream.autoDestroy = !(opts &#x26;&#x26; opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length &#x26;&#x26; !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit(&#x27;end&#x27;)
      else
        stream.emit(&#x27;data&#x27;, data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first &#x27;end&#x27; listener
  //must call destroy next tick, to make sure we&#x27;re after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for &#x27;end&#x27;

  stream.on(&#x27;end&#x27;, function () {
    stream.readable = false
    if(!stream.writable &#x26;&#x26; stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable &#x26;&#x26; stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit(&#x27;close&#x27;)
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit(&#x27;resume&#x27;)
    }
    drain()
    //may have become paused again,
    //as drain emits &#x27;data&#x27;.
    if(!stream.paused)
      stream.emit(&#x27;drain&#x27;)
    return stream
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


//
// map sync
//

es.mapSync = function (sync) {
return es.<span class="apidocCodeKeywordSpan">through</span>(function write(data) {
  var mappedData
  try {
    mappedData = sync(data)
  } catch (err) {
    return this.emit(&#x27;error&#x27;, err)
  }
  if (mappedData !== undefined)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.wait" id="apidoc.element.event-stream.wait">
        function <span class="apidocSignatureSpan">event-stream.</span>wait
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wait = function (callback) {
  var arr = []
  return es.through(function (data) { arr.push(data) },
    function () {
      var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr)
        : arr.join(&#x27;&#x27;)
      this.emit(&#x27;data&#x27;, body)
      this.emit(&#x27;end&#x27;)
      if(callback) callback(null, body)
    })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// this is still supported for legacy reasons.
//

es.join = function (str) {

//legacy api
if(&#x27;function&#x27; === typeof str)
  return es.<span class="apidocCodeKeywordSpan">wait</span>(str)

var first = true
return es.through(function (data) {
  if(!first)
    this.emit(&#x27;data&#x27;, str)
  first = false
  this.emit(&#x27;data&#x27;, data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.writeArray" id="apidoc.element.event-stream.writeArray">
        function <span class="apidocSignatureSpan">event-stream.</span>writeArray
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArray = function (done) {
  if (&#x27;function&#x27; !== typeof done)
    throw new Error(&#x27;function writeArray (done): done must be function&#x27;)

  var a = new Stream ()
    , array = [], isDone = false
  a.write = function (l) {
    array.push(l)
  }
  a.end = function () {
    isDone = true
    done(null, array)
  }
  a.writable = true
  a.readable = false
  a.destroy = function () {
    a.writable = a.readable = false
    if(isDone) return
    done(new Error(&#x27;destroyed before end&#x27;), array)
  }
  return a
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

create a writeable stream from a callback,
all `data` events are stored in an array, which is passed to the callback when the stream ends.

``` js
  var es = require(&#x27;event-stream&#x27;)
    , reader = es.readArray([1, 2, 3])
    , writer = es.<span class="apidocCodeKeywordSpan">writeArray</span>(function (err, array){
      //array deepEqual [1, 2, 3]
    })

  reader.pipe(writer)
```

## pause  ()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.event-stream.index" id="apidoc.module.event-stream.index">module event-stream.index</a></h1>


    <h2>
        <a href="#apidoc.element.event-stream.index.Stream" id="apidoc.element.event-stream.index.Stream">
        function <span class="apidocSignatureSpan">event-stream.index.</span>Stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.child" id="apidoc.element.event-stream.index.child">
        function <span class="apidocSignatureSpan">event-stream.index.</span>child
        <span class="apidocSignatureSpan">(child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">child = function (child) {

  return es.duplex(child.stdin, child.stdout)

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## child (child_process)

Create a through stream from a child process ...

``` js
  var cp = require(&#x27;child_process&#x27;)

  es.<span class="apidocCodeKeywordSpan">child</span>(cp.exec(&#x27;grep Stream&#x27;)) // a through stream

```

## wait (callback)

waits for stream to emit &#x27;end&#x27;.
joins chunks of a stream into a single string or buffer.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.concat" id="apidoc.element.event-stream.index.concat">
        function <span class="apidocSignatureSpan">event-stream.index.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function () {
  var toMerge = [].slice.call(arguments)
  if (toMerge.length === 1 &#x26;&#x26; (toMerge[0] instanceof Array)) {
    toMerge = toMerge[0] //handle array as arguments object
  }
  var stream = new Stream()
  stream.setMaxListeners(0) // allow adding more than 11 streams
  var endCount = 0
  stream.writable = stream.readable = true

  if (toMerge.length) {
    toMerge.forEach(function (e) {
      e.pipe(stream, {end: false})
      var ended = false
      e.on(&#x27;end&#x27;, function () {
        if(ended) return
        ended = true
        endCount ++
        if(endCount == toMerge.length)
          stream.emit(&#x27;end&#x27;)
      })
    })
  } else {
    process.nextTick(function () {
      stream.emit(&#x27;end&#x27;)
    })
  }

  stream.write = function (data) {
    this.emit(&#x27;data&#x27;, data)
  }
  stream.destroy = function () {
    toMerge.forEach(function (e) {
      if(e.destroy) e.destroy()
    })
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// wait. callback when &#x27;end&#x27; is emitted, with all chunks appended as string.
//

es.wait = function (callback) {
  var arr = []
  return es.through(function (data) { arr.push(data) },
    function () {
      var body = Buffer.isBuffer(arr[0]) ? Buffer.<span class="apidocCodeKeywordSpan">concat</span>(arr)
        : arr.join(&#x27;&#x27;)
      this.emit(&#x27;data&#x27;, body)
      this.emit(&#x27;end&#x27;)
      if(callback) callback(null, body)
    })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.connect" id="apidoc.element.event-stream.index.connect">
        function <span class="apidocSignatureSpan">event-stream.index.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {

  var streams = [].slice.call(arguments)
    , first = streams[0]
    , last = streams[streams.length - 1]
    , thepipe = duplexer(first, last)

  if(streams.length == 1)
    return streams[0]
  else if (!streams.length)
    throw new Error(&#x27;connect called with empty args&#x27;)

  //pipe all the streams together

  function recurse (streams) {
    if(streams.length &#x3c; 2)
      return
    streams[0].pipe(streams[1])
    recurse(streams.slice(1))
  }

  recurse(streams)

  function onerror () {
    var args = [].slice.call(arguments)
    args.unshift(&#x27;error&#x27;)
    thepipe.emit.apply(thepipe, args)
  }

  //es.duplex already reemits the error from the first and last stream.
  //add a listener for the inner streams in the pipeline.
  for(var i = 1; i &#x3c; streams.length - 1; i ++)
    streams[i].on(&#x27;error&#x27;, onerror)

  return thepipe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var es = require(&#x27;../&#x27;)
, it = require(&#x27;it-is&#x27;).style(&#x27;colour&#x27;)
, d = require(&#x27;ubelt&#x27;)

function makeExamplePipe() {

return es.<span class="apidocCodeKeywordSpan">connect</span>(
  es.map(function (data, callback) {
    callback(null, data * 2)
  }),
  es.map(function (data, callback) {
    d.delay(callback)(null, data)
  }),
  es.map(function (data, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.duplex" id="apidoc.element.event-stream.index.duplex">
        function <span class="apidocSignatureSpan">event-stream.index.</span>duplex
        <span class="apidocSignatureSpan">(writer, reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function duplex(writer, reader) {
    var stream = new Stream()
    var ended = false

    forEach(writeMethods, proxyWriter)

    forEach(readMethods, proxyReader)

    forEach(readEvents, proxyStream)

    reader.on(&#x22;end&#x22;, handleEnd)

    writer.on(&#x22;drain&#x22;, function() {
      stream.emit(&#x22;drain&#x22;)
    })

    writer.on(&#x22;error&#x22;, reemit)
    reader.on(&#x22;error&#x22;, reemit)

    stream.writable = writer.writable
    stream.readable = reader.readable

    return stream

    function proxyWriter(methodName) {
        stream[methodName] = method

        function method() {
            return writer[methodName].apply(writer, arguments)
        }
    }

    function proxyReader(methodName) {
        stream[methodName] = method

        function method() {
            stream.emit(methodName)
            var func = reader[methodName]
            if (func) {
                return func.apply(reader, arguments)
            }
            reader.emit(methodName)
        }
    }

    function proxyStream(methodName) {
        reader.on(methodName, reemit)

        function reemit() {
            var args = slice.call(arguments)
            args.unshift(methodName)
            stream.emit.apply(stream, args)
        }
    }

    function handleEnd() {
        if (ended) {
            return
        }
        ended = true
        var args = slice.call(arguments)
        args.unshift(&#x22;end&#x22;)
        stream.emit.apply(stream, args)
    }

    function reemit(err) {
        stream.emit(&#x22;error&#x22;, err)
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// child -- pipe through a child process
//

es.child = function (child) {

  return es.<span class="apidocCodeKeywordSpan">duplex</span>(child.stdin, child.stdout)

}

//
// parse
//
// must be used after es.split() to ensure that each chunk represents a line
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.from" id="apidoc.element.event-stream.index.from">
        function <span class="apidocSignatureSpan">event-stream.index.</span>from
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function from(source) {
  if(Array.isArray(source)) {
		var source_index = 0, source_len = source.length;
    return from (function (i) {
      if(source_index &#x3c; source_len)
        this.emit(&#x27;data&#x27;, source[source_index++])
      else
        this.emit(&#x27;end&#x27;)
      return true
    })
  }
  var s = new Stream(), i = 0
  s.ended = false
  s.started = false
  s.readable = true
  s.writable = false
  s.paused = false
  s.ended = false
  s.pause = function () {
    s.started = true
    s.paused = true
  }
  function next () {
    s.started = true
    if(s.ended) return
    while(!s.ended &#x26;&#x26; !s.paused &#x26;&#x26; source.call(s, i++, function () {
      if(!s.ended &#x26;&#x26; !s.paused)
          process.nextTick(next);
    }))
      ;
  }
  s.resume = function () {
    s.started = true
    s.paused = false
    next()
  }
  s.on(&#x27;end&#x27;, function () {
    s.ended = true
    s.readable = false
    process.nextTick(s.destroy)
  })
  s.destroy = function () {
    s.ended = true
    s.emit(&#x27;close&#x27;)
  }
<span class="apidocCodeCommentSpan">  /*
    by default, the stream will start emitting at nextTick
    if you want, you can pause it, after pipeing.
    you can also resume before next tick, and that will also
    work.
  */
</span>  process.nextTick(function () {
    if(!s.started) s.resume()
  })
  return s
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.join" id="apidoc.element.event-stream.index.join">
        function <span class="apidocSignatureSpan">event-stream.index.</span>join
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (str) {

  //legacy api
  if(&#x27;function&#x27; === typeof str)
    return es.wait(str)

  var first = true
  return es.through(function (data) {
    if(!first)
      this.emit(&#x27;data&#x27;, str)
    first = false
    this.emit(&#x27;data&#x27;, data)
    return true
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + &#x27;\n&#x27;
  })
}

//
// replace a string within a stream.
//
// warn: just concatenates the string and then does str.split().<span class="apidocCodeKeywordSpan">join</span>().
// probably not optimal.
// for smallish responses, who cares?
// I need this for shadow-npm so it&#x27;s only relatively small json files.

es.replace = function (from, to) {
  return es.pipeline(es.split(from), es.join(to))
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.log" id="apidoc.element.event-stream.index.log">
        function <span class="apidocSignatureSpan">event-stream.index.</span>log
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (name) {
  return es.through(function (data) {
    var args = [].slice.call(arguments)
    if(name) console.error(name, data)
    else     console.error(data)
    this.emit(&#x27;data&#x27;, data)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a single data event with the reduced value once the input stream ends.

``` js
var reduce = require(&#x22;stream-reduce&#x22;);
process.stdin.pipe(reduce(function(acc, data) {
  return acc + data.length;
}, 0)).on(&#x22;data&#x22;, function(length) {
  console.<span class="apidocCodeKeywordSpan">log</span>(&#x22;stdin size:&#x22;, length);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.map" id="apidoc.element.event-stream.index.map">
        function <span class="apidocSignatureSpan">event-stream.index.</span>map
        <span class="apidocSignatureSpan">(mapper, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (mapper, opts) {

  var stream = new Stream()
    , self = this
    , inputs = 0
    , outputs = 0
    , ended = false
    , paused = false
    , destroyed = false
    , lastWritten = 0
    , inNext = false

  this.opts = opts || {};
  var errorEventName = this.opts.failures ? &#x27;failure&#x27; : &#x27;error&#x27;;

  // Items that are not ready to be written yet (because they would come out of
  // order) get stuck in a queue for later.
  var writeQueue = {}

  stream.writable = true
  stream.readable = true

  function queueData (data, number) {
    var nextToWrite = lastWritten + 1

    if (number === nextToWrite) {
      // If it&#x27;s next, and its not undefined write it
      if (data !== undefined) {
        stream.emit.apply(stream, [&#x27;data&#x27;, data])
      }
      lastWritten ++
      nextToWrite ++
    } else {
      // Otherwise queue it for later.
      writeQueue[number] = data
    }

    // If the next value is in the queue, write it
    if (writeQueue.hasOwnProperty(nextToWrite)) {
      var dataToWrite = writeQueue[nextToWrite]
      delete writeQueue[nextToWrite]
      return queueData(dataToWrite, nextToWrite)
    }

    outputs ++
    if(inputs === outputs) {
      if(paused) paused = false, stream.emit(&#x27;drain&#x27;) //written all the incoming events
      if(ended) end()
    }
  }

  function next (err, data, number) {
    if(destroyed) return
    inNext = true

    if (!err || self.opts.failures) {
      queueData(data, number)
    }

    if (err) {
      stream.emit.apply(stream, [ errorEventName, err ]);
    }

    inNext = false;
  }

  // Wrap the mapper function by calling its callback with the order number of
  // the item in the stream.
  function wrappedMapper (input, number, callback) {
    return mapper.call(null, input, function(err, data){
      callback(err, data, number)
    })
  }

  stream.write = function (data) {
    if(ended) throw new Error(&#x27;map stream is not writable&#x27;)
    inNext = false
    inputs ++

    try {
      //catch sync errors and handle them like async errors
      var written = wrappedMapper(data, inputs, next)
      paused = (written === false)
      return !paused
    } catch (err) {
      //if the callback has been called syncronously, and the error
      //has occured in an listener, throw it again.
      if(inNext)
        throw err
      next(err)
      return !paused
    }
  }

  function end (data) {
    //if end was called with args, write it,
    ended = true //write will emit &#x27;end&#x27; if ended is true
    stream.writable = false
    if(data !== undefined) {
      return queueData(data, inputs)
    } else if (inputs == outputs) { //wait for processing
      stream.readable = false, stream.emit(&#x27;end&#x27;), stream.destroy()
    }
  }

  stream.end = function (data) {
    if(ended) return
    end()
  }

  stream.destroy = function () {
    ended = destroyed = true
    stream.writable = stream.readable = paused = false
    process.nextTick(function () {
      stream.emit(&#x27;close&#x27;)
    })
  }
  stream.pause = function () {
    paused = true
  }

  stream.resume = function () {
    paused = false
  }

  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!module.parent) {
  var es = require(&#x27;event-stream&#x27;)
  var inspect = require(&#x27;util&#x27;).inspect

  process.stdin                        //connect streams together with `pipe`
    .pipe(es.split())                  //split stream to break on newlines
    .pipe(es.<span class="apidocCodeKeywordSpan">map</span>(function (data, cb) { //turn this async function into a stream
      cb(null
        , inspect(JSON.parse(data)))   //render it nicely
    }))
    .pipe(process.stdout)              // pipe it to stdout !
}
```
run it ...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.mapSync" id="apidoc.element.event-stream.index.mapSync">
        function <span class="apidocSignatureSpan">event-stream.index.</span>mapSync
        <span class="apidocSignatureSpan">(sync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapSync = function (sync) {
  return es.through(function write(data) {
    var mappedData
    try {
      mappedData = sync(data)
    } catch (err) {
      return this.emit(&#x27;error&#x27;, err)
    }
    if (mappedData !== undefined)
      this.emit(&#x27;data&#x27;, mappedData)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
//
// stringify
//

es.stringify = function () {
  var Buffer = require(&#x27;buffer&#x27;).Buffer
  return es.<span class="apidocCodeKeywordSpan">mapSync</span>(function (e){
    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + &#x27;\n&#x27;
  })
}

//
// replace a string within a stream.
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.merge" id="apidoc.element.event-stream.index.merge">
        function <span class="apidocSignatureSpan">event-stream.index.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function () {
  var toMerge = [].slice.call(arguments)
  if (toMerge.length === 1 &#x26;&#x26; (toMerge[0] instanceof Array)) {
    toMerge = toMerge[0] //handle array as arguments object
  }
  var stream = new Stream()
  stream.setMaxListeners(0) // allow adding more than 11 streams
  var endCount = 0
  stream.writable = stream.readable = true

  if (toMerge.length) {
    toMerge.forEach(function (e) {
      e.pipe(stream, {end: false})
      var ended = false
      e.on(&#x27;end&#x27;, function () {
        if(ended) return
        ended = true
        endCount ++
        if(endCount == toMerge.length)
          stream.emit(&#x27;end&#x27;)
      })
    })
  } else {
    process.nextTick(function () {
      stream.emit(&#x27;end&#x27;)
    })
  }

  stream.write = function (data) {
    this.emit(&#x27;data&#x27;, data)
  }
  stream.destroy = function () {
    toMerge.forEach(function (e) {
      if(e.destroy) e.destroy()
    })
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3e; concat â†’ merge

Merges streams into one and returns it.
Incoming data will be emitted as soon it comes into - no ordering will be applied (for example: `data1 data1 data2 data1 data2` -
where `data1` and `data2` is data from two streams).
Counts how many streams were passed to it and emits end only when all streams emitted end.

```js
es.<span class="apidocCodeKeywordSpan">merge</span>(
  process.stdout,
  process.stderr
).pipe(fs.createWriteStream(&#x27;output.log&#x27;));
```

It can also take an Array of streams as input like this:
```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.parse" id="apidoc.element.event-stream.index.parse">
        function <span class="apidocSignatureSpan">event-stream.index.</span>parse
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (options) {
  var emitError = !!(options ? options.error : false)
  return es.through(function (data) {
    var obj
    try {
      if(data) //ignore empty lines
        obj = JSON.parse(data.toString())
    } catch (err) {
      if (emitError)
        return this.emit(&#x27;error&#x27;, err)
      return console.error(err, &#x27;attempting to parse:&#x27;, data)
    }
    //ignore lines that where only whitespace.
    if(obj !== undefined)
      this.emit(&#x27;data&#x27;, obj)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

}

//
// parse
//
// must be used after es.split() to ensure that each chunk represents a line
// source.pipe(es.split()).pipe(es.<span class="apidocCodeKeywordSpan">parse</span>())

es.parse = function (options) {
var emitError = !!(options ? options.error : false)
return es.through(function (data) {
  var obj
  try {
    if(data) //ignore empty lines
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.pause" id="apidoc.element.event-stream.index.pause">
        function <span class="apidocSignatureSpan">event-stream.index.</span>pause
        <span class="apidocSignatureSpan">(write, end, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function through(write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts &#x26;&#x26; opts.autoPause   === false)
  stream.autoDestroy = !(opts &#x26;&#x26; opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length &#x26;&#x26; !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit(&#x27;end&#x27;)
      else
        stream.emit(&#x27;data&#x27;, data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first &#x27;end&#x27; listener
  //must call destroy next tick, to make sure we&#x27;re after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for &#x27;end&#x27;

  stream.on(&#x27;end&#x27;, function () {
    stream.readable = false
    if(!stream.writable &#x26;&#x26; stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable &#x26;&#x26; stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit(&#x27;close&#x27;)
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit(&#x27;resume&#x27;)
    }
    drain()
    //may have become paused again,
    //as drain emits &#x27;data&#x27;.
    if(!stream.paused)
      stream.emit(&#x27;drain&#x27;)
    return stream
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

[node Stream documentation](http://nodejs.org/api/stream.html)

## through (write?, end?)

Re-emits data synchronously. Easy way to create synchronous through streams.
Pass in optional `write` and `end` methods. They will be called in the
context of the stream. Use `this.<span class="apidocCodeKeywordSpan">pause</span>()` and `this.resume()` to manage flow.
Check `this.paused` to see current flow state. (write always returns `!this.paused`)

this function is the basis for most of the synchronous streams in `event-stream`.

``` js

es.through(function write(data) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.pipe" id="apidoc.element.event-stream.index.pipe">
        function <span class="apidocSignatureSpan">event-stream.index.</span>pipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function () {

  var streams = [].slice.call(arguments)
    , first = streams[0]
    , last = streams[streams.length - 1]
    , thepipe = duplexer(first, last)

  if(streams.length == 1)
    return streams[0]
  else if (!streams.length)
    throw new Error(&#x27;connect called with empty args&#x27;)

  //pipe all the streams together

  function recurse (streams) {
    if(streams.length &#x3c; 2)
      return
    streams[0].pipe(streams[1])
    recurse(streams.slice(1))
  }

  recurse(streams)

  function onerror () {
    var args = [].slice.call(arguments)
    args.unshift(&#x27;error&#x27;)
    thepipe.emit.apply(thepipe, args)
  }

  //es.duplex already reemits the error from the first and last stream.
  //add a listener for the inner streams in the pipeline.
  for(var i = 1; i &#x3c; streams.length - 1; i ++)
    streams[i].on(&#x27;error&#x27;, onerror)

  return thepipe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var stream = new Stream()
stream.setMaxListeners(0) // allow adding more than 11 streams
var endCount = 0
stream.writable = stream.readable = true

if (toMerge.length) {
  toMerge.forEach(function (e) {
    e.<span class="apidocCodeKeywordSpan">pipe</span>(stream, {end: false})
    var ended = false
    e.on(&#x27;end&#x27;, function () {
      if(ended) return
      ended = true
      endCount ++
      if(endCount == toMerge.length)
        stream.emit(&#x27;end&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.pipeable" id="apidoc.element.event-stream.index.pipeable">
        function <span class="apidocSignatureSpan">event-stream.index.</span>pipeable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipeable = function () {
  throw new Error(&#x27;[EVENT-STREAM] es.pipeable is deprecated&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.pipeline" id="apidoc.element.event-stream.index.pipeline">
        function <span class="apidocSignatureSpan">event-stream.index.</span>pipeline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipeline = function () {

  var streams = [].slice.call(arguments)
    , first = streams[0]
    , last = streams[streams.length - 1]
    , thepipe = duplexer(first, last)

  if(streams.length == 1)
    return streams[0]
  else if (!streams.length)
    throw new Error(&#x27;connect called with empty args&#x27;)

  //pipe all the streams together

  function recurse (streams) {
    if(streams.length &#x3c; 2)
      return
    streams[0].pipe(streams[1])
    recurse(streams.slice(1))
  }

  recurse(streams)

  function onerror () {
    var args = [].slice.call(arguments)
    args.unshift(&#x27;error&#x27;)
    thepipe.emit.apply(thepipe, args)
  }

  //es.duplex already reemits the error from the first and last stream.
  //add a listener for the inner streams in the pipeline.
  for(var i = 1; i &#x3c; streams.length - 1; i ++)
    streams[i].on(&#x27;error&#x27;, onerror)

  return thepipe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// warn: just concatenates the string and then does str.split().join().
// probably not optimal.
// for smallish responses, who cares?
// I need this for shadow-npm so it&#x27;s only relatively small json files.

es.replace = function (from, to) {
  return es.<span class="apidocCodeKeywordSpan">pipeline</span>(es.split(from), es.join(to))
}

//
// join chunks with a joiner. just like Array#join
// also accepts a callback that is passed the chunks appended together
// this is still supported for legacy reasons.
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.readArray" id="apidoc.element.event-stream.index.readArray">
        function <span class="apidocSignatureSpan">event-stream.index.</span>readArray
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArray = function (array) {
  var stream = new Stream()
    , i = 0
    , paused = false
    , ended = false

  stream.readable = true
  stream.writable = false

  if(!Array.isArray(array))
    throw new Error(&#x27;event-stream.read expects an array&#x27;)

  stream.resume = function () {
    if(ended) return
    paused = false
    var l = array.length
    while(i &#x3c; l &#x26;&#x26; !paused &#x26;&#x26; !ended) {
      stream.emit(&#x27;data&#x27;, array[i++])
    }
    if(i == l &#x26;&#x26; !ended)
      ended = true, stream.readable = false, stream.emit(&#x27;end&#x27;)
  }
  process.nextTick(stream.resume)
  stream.pause = function () {
     paused = true
  }
  stream.destroy = function () {
    ended = true
    stream.emit(&#x27;close&#x27;)
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Create a readable stream from an Array.

Just emit each item as a data event, respecting `pause` and `resume`.

``` js
  var es = require(&#x27;event-stream&#x27;)
    , reader = es.<span class="apidocCodeKeywordSpan">readArray</span>([1,2,3])

  reader.pipe(...)
```

If you want the stream behave like a 0.10 stream you will need to wrap it using [`Readable.wrap()`](http://nodejs.org/api/stream
.html#stream_readable_wrap_stream) function. Example:

``` js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.readable" id="apidoc.element.event-stream.index.readable">
        function <span class="apidocSignatureSpan">event-stream.index.</span>readable
        <span class="apidocSignatureSpan">(func, continueOnError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readable = function (func, continueOnError) {
  var stream = new Stream()
    , i = 0
    , paused = false
    , ended = false
    , reading = false

  stream.readable = true
  stream.writable = false

  if(&#x27;function&#x27; !== typeof func)
    throw new Error(&#x27;event-stream.readable expects async function&#x27;)

  stream.on(&#x27;end&#x27;, function () { ended = true })

  function get (err, data) {

    if(err) {
      stream.emit(&#x27;error&#x27;, err)
      if(!continueOnError) stream.emit(&#x27;end&#x27;)
    } else if (arguments.length &#x3e; 1)
      stream.emit(&#x27;data&#x27;, data)

    immediately(function () {
      if(ended || paused || reading) return
      try {
        reading = true
        func.call(stream, i++, function () {
          reading = false
          get.apply(null, arguments)
        })
      } catch (err) {
        stream.emit(&#x27;error&#x27;, err)
      }
    })
  }
  stream.resume = function () {
    paused = false
    get()
  }
  process.nextTick(get)
  stream.pause = function () {
     paused = true
  }
  stream.destroy = function () {
    stream.emit(&#x27;end&#x27;)
    stream.emit(&#x27;close&#x27;)
    ended = true
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
create a readable stream (that respects pause) from an async function.
while the stream is not paused,
the function will be polled with `(count, callback)`,
and `this`  will be the readable stream.

``` js

es.<span class="apidocCodeKeywordSpan">readable</span>(function (count, callback) {
if(streamHasEnded)
  return this.emit(&#x27;end&#x27;)

//...

this.emit(&#x27;data&#x27;, data) //use this way to emit multiple chunks per call.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.replace" id="apidoc.element.event-stream.index.replace">
        function <span class="apidocSignatureSpan">event-stream.index.</span>replace
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (from, to) {
  return es.pipeline(es.split(from), es.join(to))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
reader.pipe(join)

}


exports [&#x27;fizz buzz replace&#x27;] = function (test) {
var split = es.split(/(1)/)
var replace = es.<span class="apidocCodeKeywordSpan">replace</span>(&#x27;7&#x27;, &#x27;seven&#x27;)
//  var x = spec(replace).through()
split
  .pipe(replace)
  .pipe(es.join(function (err, string) {
    it(string).equal(fizz7buzz)
  }))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.split" id="apidoc.element.event-stream.index.split">
        function <span class="apidocSignatureSpan">event-stream.index.</span>split
        <span class="apidocSignatureSpan">(matcher, mapper, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function split(matcher, mapper, options) {
  var decoder = new Decoder()
  var soFar = &#x27;&#x27;
  var maxLength = options &#x26;&#x26; options.maxLength;
  if(&#x27;function&#x27; === typeof matcher)
    mapper = matcher, matcher = null
  if (!matcher)
    matcher = /\r?\n/

  function emit(stream, piece) {
    if(mapper) {
      try {
        piece = mapper(piece)
      }
      catch (err) {
        return stream.emit(&#x27;error&#x27;, err)
      }
      if(&#x27;undefined&#x27; !== typeof piece)
        stream.queue(piece)
    }
    else
      stream.queue(piece)
  }

  function next (stream, buffer) {
    var pieces = ((soFar != null ? soFar : &#x27;&#x27;) + buffer).split(matcher)
    soFar = pieces.pop()

    if (maxLength &#x26;&#x26; soFar.length &#x3e; maxLength)
      stream.emit(&#x27;error&#x27;, new Error(&#x27;maximum buffer reached&#x27;))

    for (var i = 0; i &#x3c; pieces.length; i++) {
      var piece = pieces[i]
      emit(stream, piece)
    }
  }

  return through(function (b) {
    next(this, decoder.write(b))
  },
  function () {
    if(decoder.end)
      next(this, decoder.end())
    if(soFar != null)
      emit(this, soFar)
    this.queue(null)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return es.duplex(child.stdin, child.stdout)

}

//
// parse
//
// must be used after es.<span class="apidocCodeKeywordSpan">split</span>() to ensure that each chunk represents a line
// source.pipe(es.split()).pipe(es.parse())

es.parse = function (options) {
var emitError = !!(options ? options.error : false)
return es.through(function (data) {
  var obj
  try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.stringify" id="apidoc.element.event-stream.index.stringify">
        function <span class="apidocSignatureSpan">event-stream.index.</span>stringify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function () {
  var Buffer = require(&#x27;buffer&#x27;).Buffer
  return es.mapSync(function (e){
    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + &#x27;\n&#x27;
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// stringify
//

es.stringify = function () {
  var Buffer = require(&#x27;buffer&#x27;).Buffer
  return es.mapSync(function (e){
    return JSON.<span class="apidocCodeKeywordSpan">stringify</span>(Buffer.isBuffer(e) ? e.toString() : e) + &#x27;\n&#x27;
  })
}

//
// replace a string within a stream.
//
// warn: just concatenates the string and then does str.split().join().
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.through" id="apidoc.element.event-stream.index.through">
        function <span class="apidocSignatureSpan">event-stream.index.</span>through
        <span class="apidocSignatureSpan">(write, end, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function through(write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts &#x26;&#x26; opts.autoPause   === false)
  stream.autoDestroy = !(opts &#x26;&#x26; opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length &#x26;&#x26; !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit(&#x27;end&#x27;)
      else
        stream.emit(&#x27;data&#x27;, data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first &#x27;end&#x27; listener
  //must call destroy next tick, to make sure we&#x27;re after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for &#x27;end&#x27;

  stream.on(&#x27;end&#x27;, function () {
    stream.readable = false
    if(!stream.writable &#x26;&#x26; stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable &#x26;&#x26; stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit(&#x27;close&#x27;)
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit(&#x27;resume&#x27;)
    }
    drain()
    //may have become paused again,
    //as drain emits &#x27;data&#x27;.
    if(!stream.paused)
      stream.emit(&#x27;drain&#x27;)
    return stream
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


//
// map sync
//

es.mapSync = function (sync) {
return es.<span class="apidocCodeKeywordSpan">through</span>(function write(data) {
  var mappedData
  try {
    mappedData = sync(data)
  } catch (err) {
    return this.emit(&#x27;error&#x27;, err)
  }
  if (mappedData !== undefined)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.wait" id="apidoc.element.event-stream.index.wait">
        function <span class="apidocSignatureSpan">event-stream.index.</span>wait
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wait = function (callback) {
  var arr = []
  return es.through(function (data) { arr.push(data) },
    function () {
      var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr)
        : arr.join(&#x27;&#x27;)
      this.emit(&#x27;data&#x27;, body)
      this.emit(&#x27;end&#x27;)
      if(callback) callback(null, body)
    })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// this is still supported for legacy reasons.
//

es.join = function (str) {

//legacy api
if(&#x27;function&#x27; === typeof str)
  return es.<span class="apidocCodeKeywordSpan">wait</span>(str)

var first = true
return es.through(function (data) {
  if(!first)
    this.emit(&#x27;data&#x27;, str)
  first = false
  this.emit(&#x27;data&#x27;, data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.index.writeArray" id="apidoc.element.event-stream.index.writeArray">
        function <span class="apidocSignatureSpan">event-stream.index.</span>writeArray
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArray = function (done) {
  if (&#x27;function&#x27; !== typeof done)
    throw new Error(&#x27;function writeArray (done): done must be function&#x27;)

  var a = new Stream ()
    , array = [], isDone = false
  a.write = function (l) {
    array.push(l)
  }
  a.end = function () {
    isDone = true
    done(null, array)
  }
  a.writable = true
  a.readable = false
  a.destroy = function () {
    a.writable = a.readable = false
    if(isDone) return
    done(new Error(&#x27;destroyed before end&#x27;), array)
  }
  return a
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

create a writeable stream from a callback,
all `data` events are stored in an array, which is passed to the callback when the stream ends.

``` js
  var es = require(&#x27;event-stream&#x27;)
    , reader = es.readArray([1, 2, 3])
    , writer = es.<span class="apidocCodeKeywordSpan">writeArray</span>(function (err, array){
      //array deepEqual [1, 2, 3]
    })

  reader.pipe(writer)
```

## pause  ()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.event-stream.through" id="apidoc.module.event-stream.through">module event-stream.through</a></h1>


    <h2>
        <a href="#apidoc.element.event-stream.through.through" id="apidoc.element.event-stream.through.through">
        function <span class="apidocSignatureSpan">event-stream.</span>through
        <span class="apidocSignatureSpan">(write, end, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function through(write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts &#x26;&#x26; opts.autoPause   === false)
  stream.autoDestroy = !(opts &#x26;&#x26; opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length &#x26;&#x26; !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit(&#x27;end&#x27;)
      else
        stream.emit(&#x27;data&#x27;, data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first &#x27;end&#x27; listener
  //must call destroy next tick, to make sure we&#x27;re after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for &#x27;end&#x27;

  stream.on(&#x27;end&#x27;, function () {
    stream.readable = false
    if(!stream.writable &#x26;&#x26; stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable &#x26;&#x26; stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit(&#x27;close&#x27;)
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit(&#x27;resume&#x27;)
    }
    drain()
    //may have become paused again,
    //as drain emits &#x27;data&#x27;.
    if(!stream.paused)
      stream.emit(&#x27;drain&#x27;)
    return stream
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


//
// map sync
//

es.mapSync = function (sync) {
return es.<span class="apidocCodeKeywordSpan">through</span>(function write(data) {
  var mappedData
  try {
    mappedData = sync(data)
  } catch (err) {
    return this.emit(&#x27;error&#x27;, err)
  }
  if (mappedData !== undefined)
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
