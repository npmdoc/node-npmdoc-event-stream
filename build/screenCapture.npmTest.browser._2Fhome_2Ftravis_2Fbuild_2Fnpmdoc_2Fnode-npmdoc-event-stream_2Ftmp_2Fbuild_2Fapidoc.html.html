<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://github.com/dominictarr/event-stream">event-stream (v3.3.4)</a>
</h1>
<h4>construct pipes of streams of events</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.event-stream">module event-stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.Stream">
            function <span class="apidocSignatureSpan">event-stream.</span>Stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.child">
            function <span class="apidocSignatureSpan">event-stream.</span>child
            <span class="apidocSignatureSpan">(child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.concat">
            function <span class="apidocSignatureSpan">event-stream.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.connect">
            function <span class="apidocSignatureSpan">event-stream.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.duplex">
            function <span class="apidocSignatureSpan">event-stream.</span>duplex
            <span class="apidocSignatureSpan">(writer, reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.from">
            function <span class="apidocSignatureSpan">event-stream.</span>from
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.join">
            function <span class="apidocSignatureSpan">event-stream.</span>join
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.log">
            function <span class="apidocSignatureSpan">event-stream.</span>log
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.map">
            function <span class="apidocSignatureSpan">event-stream.</span>map
            <span class="apidocSignatureSpan">(mapper, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.mapSync">
            function <span class="apidocSignatureSpan">event-stream.</span>mapSync
            <span class="apidocSignatureSpan">(sync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.merge">
            function <span class="apidocSignatureSpan">event-stream.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.parse">
            function <span class="apidocSignatureSpan">event-stream.</span>parse
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.pause">
            function <span class="apidocSignatureSpan">event-stream.</span>pause
            <span class="apidocSignatureSpan">(write, end, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.pipe">
            function <span class="apidocSignatureSpan">event-stream.</span>pipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.pipeable">
            function <span class="apidocSignatureSpan">event-stream.</span>pipeable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.pipeline">
            function <span class="apidocSignatureSpan">event-stream.</span>pipeline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.readArray">
            function <span class="apidocSignatureSpan">event-stream.</span>readArray
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.readable">
            function <span class="apidocSignatureSpan">event-stream.</span>readable
            <span class="apidocSignatureSpan">(func, continueOnError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.replace">
            function <span class="apidocSignatureSpan">event-stream.</span>replace
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.split">
            function <span class="apidocSignatureSpan">event-stream.</span>split
            <span class="apidocSignatureSpan">(matcher, mapper, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.stringify">
            function <span class="apidocSignatureSpan">event-stream.</span>stringify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.through">
            function <span class="apidocSignatureSpan">event-stream.</span>through
            <span class="apidocSignatureSpan">(write, end, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.wait">
            function <span class="apidocSignatureSpan">event-stream.</span>wait
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.writeArray">
            function <span class="apidocSignatureSpan">event-stream.</span>writeArray
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.event-stream.through">module event-stream.through</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.event-stream.through.through">
            function <span class="apidocSignatureSpan">event-stream.</span>through
            <span class="apidocSignatureSpan">(write, end, opts)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.event-stream" id="apidoc.module.event-stream">module event-stream</a></h1>


    <h2>
        <a href="#apidoc.element.event-stream.Stream" id="apidoc.element.event-stream.Stream">
        function <span class="apidocSignatureSpan">event-stream.</span>Stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.child" id="apidoc.element.event-stream.child">
        function <span class="apidocSignatureSpan">event-stream.</span>child
        <span class="apidocSignatureSpan">(child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">child = function (child) {

  return es.duplex(child.stdin, child.stdout)

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## child (child_process)

Create a through stream from a child process ...

``` js
  var cp = require('child_process')

  es.<span class="apidocCodeKeywordSpan">child</span>(cp.exec('grep Stream')) // a through stream

```

## wait (callback)

waits for stream to emit 'end'.
joins chunks of a stream into a single string or buffer.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.concat" id="apidoc.element.event-stream.concat">
        function <span class="apidocSignatureSpan">event-stream.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function () {
  var toMerge = [].slice.call(arguments)
  if (toMerge.length === 1 &amp;&amp; (toMerge[0] instanceof Array)) {
    toMerge = toMerge[0] //handle array as arguments object
  }
  var stream = new Stream()
  stream.setMaxListeners(0) // allow adding more than 11 streams
  var endCount = 0
  stream.writable = stream.readable = true

  if (toMerge.length) {
    toMerge.forEach(function (e) {
      e.pipe(stream, {end: false})
      var ended = false
      e.on('end', function () {
        if(ended) return
        ended = true
        endCount ++
        if(endCount == toMerge.length)
          stream.emit('end')
      })
    })
  } else {
    process.nextTick(function () {
      stream.emit('end')
    })
  }

  stream.write = function (data) {
    this.emit('data', data)
  }
  stream.destroy = function () {
    toMerge.forEach(function (e) {
      if(e.destroy) e.destroy()
    })
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// wait. callback when 'end' is emitted, with all chunks appended as string.
//

es.wait = function (callback) {
  var arr = []
  return es.through(function (data) { arr.push(data) },
    function () {
      var body = Buffer.isBuffer(arr[0]) ? Buffer.<span class="apidocCodeKeywordSpan">concat</span>(arr)
        : arr.join('')
      this.emit('data', body)
      this.emit('end')
      if(callback) callback(null, body)
    })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.connect" id="apidoc.element.event-stream.connect">
        function <span class="apidocSignatureSpan">event-stream.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {

  var streams = [].slice.call(arguments)
    , first = streams[0]
    , last = streams[streams.length - 1]
    , thepipe = duplexer(first, last)

  if(streams.length == 1)
    return streams[0]
  else if (!streams.length)
    throw new Error('connect called with empty args')

  //pipe all the streams together

  function recurse (streams) {
    if(streams.length &lt; 2)
      return
    streams[0].pipe(streams[1])
    recurse(streams.slice(1))
  }

  recurse(streams)

  function onerror () {
    var args = [].slice.call(arguments)
    args.unshift('error')
    thepipe.emit.apply(thepipe, args)
  }

  //es.duplex already reemits the error from the first and last stream.
  //add a listener for the inner streams in the pipeline.
  for(var i = 1; i &lt; streams.length - 1; i ++)
    streams[i].on('error', onerror)

  return thepipe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.duplex" id="apidoc.element.event-stream.duplex">
        function <span class="apidocSignatureSpan">event-stream.</span>duplex
        <span class="apidocSignatureSpan">(writer, reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function duplex(writer, reader) {
    var stream = new Stream()
    var ended = false

    forEach(writeMethods, proxyWriter)

    forEach(readMethods, proxyReader)

    forEach(readEvents, proxyStream)

    reader.on("end", handleEnd)

    writer.on("drain", function() {
      stream.emit("drain")
    })

    writer.on("error", reemit)
    reader.on("error", reemit)

    stream.writable = writer.writable
    stream.readable = reader.readable

    return stream

    function proxyWriter(methodName) {
        stream[methodName] = method

        function method() {
            return writer[methodName].apply(writer, arguments)
        }
    }

    function proxyReader(methodName) {
        stream[methodName] = method

        function method() {
            stream.emit(methodName)
            var func = reader[methodName]
            if (func) {
                return func.apply(reader, arguments)
            }
            reader.emit(methodName)
        }
    }

    function proxyStream(methodName) {
        reader.on(methodName, reemit)

        function reemit() {
            var args = slice.call(arguments)
            args.unshift(methodName)
            stream.emit.apply(stream, args)
        }
    }

    function handleEnd() {
        if (ended) {
            return
        }
        ended = true
        var args = slice.call(arguments)
        args.unshift("end")
        stream.emit.apply(stream, args)
    }

    function reemit(err) {
        stream.emit("error", err)
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// child -- pipe through a child process
//

es.child = function (child) {

  return es.<span class="apidocCodeKeywordSpan">duplex</span>(child.stdin, child.stdout)

}

//
// parse
//
// must be used after es.split() to ensure that each chunk represents a line
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.from" id="apidoc.element.event-stream.from">
        function <span class="apidocSignatureSpan">event-stream.</span>from
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function from(source) {
  if(Array.isArray(source)) {
		var source_index = 0, source_len = source.length;
    return from (function (i) {
      if(source_index &lt; source_len)
        this.emit('data', source[source_index++])
      else
        this.emit('end')
      return true
    })
  }
  var s = new Stream(), i = 0
  s.ended = false
  s.started = false
  s.readable = true
  s.writable = false
  s.paused = false
  s.ended = false
  s.pause = function () {
    s.started = true
    s.paused = true
  }
  function next () {
    s.started = true
    if(s.ended) return
    while(!s.ended &amp;&amp; !s.paused &amp;&amp; source.call(s, i++, function () {
      if(!s.ended &amp;&amp; !s.paused)
          process.nextTick(next);
    }))
      ;
  }
  s.resume = function () {
    s.started = true
    s.paused = false
    next()
  }
  s.on('end', function () {
    s.ended = true
    s.readable = false
    process.nextTick(s.destroy)
  })
  s.destroy = function () {
    s.ended = true
    s.emit('close')
  }
<span class="apidocCodeCommentSpan">  /*
    by default, the stream will start emitting at nextTick
    if you want, you can pause it, after pipeing.
    you can also resume before next tick, and that will also
    work.
  */
</span>  process.nextTick(function () {
    if(!s.started) s.resume()
  })
  return s
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.join" id="apidoc.element.event-stream.join">
        function <span class="apidocSignatureSpan">event-stream.</span>join
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (str) {

  //legacy api
  if('function' === typeof str)
    return es.wait(str)

  var first = true
  return es.through(function (data) {
    if(!first)
      this.emit('data', str)
    first = false
    this.emit('data', data)
    return true
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + '\n'
  })
}

//
// replace a string within a stream.
//
// warn: just concatenates the string and then does str.split().<span class="apidocCodeKeywordSpan">join</span>().
// probably not optimal.
// for smallish responses, who cares?
// I need this for shadow-npm so it's only relatively small json files.

es.replace = function (from, to) {
  return es.pipeline(es.split(from), es.join(to))
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.log" id="apidoc.element.event-stream.log">
        function <span class="apidocSignatureSpan">event-stream.</span>log
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (name) {
  return es.through(function (data) {
    var args = [].slice.call(arguments)
    if(name) console.error(name, data)
    else     console.error(data)
    this.emit('data', data)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a single data event with the reduced value once the input stream ends.

``` js
var reduce = require("stream-reduce");
process.stdin.pipe(reduce(function(acc, data) {
  return acc + data.length;
}, 0)).on("data", function(length) {
  console.<span class="apidocCodeKeywordSpan">log</span>("stdin size:", length);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.map" id="apidoc.element.event-stream.map">
        function <span class="apidocSignatureSpan">event-stream.</span>map
        <span class="apidocSignatureSpan">(mapper, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (mapper, opts) {

  var stream = new Stream()
    , self = this
    , inputs = 0
    , outputs = 0
    , ended = false
    , paused = false
    , destroyed = false
    , lastWritten = 0
    , inNext = false

  this.opts = opts || {};
  var errorEventName = this.opts.failures ? 'failure' : 'error';

  // Items that are not ready to be written yet (because they would come out of
  // order) get stuck in a queue for later.
  var writeQueue = {}

  stream.writable = true
  stream.readable = true

  function queueData (data, number) {
    var nextToWrite = lastWritten + 1

    if (number === nextToWrite) {
      // If it's next, and its not undefined write it
      if (data !== undefined) {
        stream.emit.apply(stream, ['data', data])
      }
      lastWritten ++
      nextToWrite ++
    } else {
      // Otherwise queue it for later.
      writeQueue[number] = data
    }

    // If the next value is in the queue, write it
    if (writeQueue.hasOwnProperty(nextToWrite)) {
      var dataToWrite = writeQueue[nextToWrite]
      delete writeQueue[nextToWrite]
      return queueData(dataToWrite, nextToWrite)
    }

    outputs ++
    if(inputs === outputs) {
      if(paused) paused = false, stream.emit('drain') //written all the incoming events
      if(ended) end()
    }
  }

  function next (err, data, number) {
    if(destroyed) return
    inNext = true

    if (!err || self.opts.failures) {
      queueData(data, number)
    }

    if (err) {
      stream.emit.apply(stream, [ errorEventName, err ]);
    }

    inNext = false;
  }

  // Wrap the mapper function by calling its callback with the order number of
  // the item in the stream.
  function wrappedMapper (input, number, callback) {
    return mapper.call(null, input, function(err, data){
      callback(err, data, number)
    })
  }

  stream.write = function (data) {
    if(ended) throw new Error('map stream is not writable')
    inNext = false
    inputs ++

    try {
      //catch sync errors and handle them like async errors
      var written = wrappedMapper(data, inputs, next)
      paused = (written === false)
      return !paused
    } catch (err) {
      //if the callback has been called syncronously, and the error
      //has occured in an listener, throw it again.
      if(inNext)
        throw err
      next(err)
      return !paused
    }
  }

  function end (data) {
    //if end was called with args, write it,
    ended = true //write will emit 'end' if ended is true
    stream.writable = false
    if(data !== undefined) {
      return queueData(data, inputs)
    } else if (inputs == outputs) { //wait for processing
      stream.readable = false, stream.emit('end'), stream.destroy()
    }
  }

  stream.end = function (data) {
    if(ended) return
    end()
  }

  stream.destroy = function () {
    ended = destroyed = true
    stream.writable = stream.readable = paused = false
    process.nextTick(function () {
      stream.emit('close')
    })
  }
  stream.pause = function () {
    paused = true
  }

  stream.resume = function () {
    paused = false
  }

  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!module.parent) {
  var es = require('event-stream')
  var inspect = require('util').inspect

  process.stdin                        //connect streams together with `pipe`
    .pipe(es.split())                  //split stream to break on newlines
    .pipe(es.<span class="apidocCodeKeywordSpan">map</span>(function (data, cb) { //turn this async function into a stream
      cb(null
        , inspect(JSON.parse(data)))   //render it nicely
    }))
    .pipe(process.stdout)              // pipe it to stdout !
}
```
run it ...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.mapSync" id="apidoc.element.event-stream.mapSync">
        function <span class="apidocSignatureSpan">event-stream.</span>mapSync
        <span class="apidocSignatureSpan">(sync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapSync = function (sync) {
  return es.through(function write(data) {
    var mappedData
    try {
      mappedData = sync(data)
    } catch (err) {
      return this.emit('error', err)
    }
    if (mappedData !== undefined)
      this.emit('data', mappedData)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
//
// stringify
//

es.stringify = function () {
  var Buffer = require('buffer').Buffer
  return es.<span class="apidocCodeKeywordSpan">mapSync</span>(function (e){
    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + '\n'
  })
}

//
// replace a string within a stream.
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.merge" id="apidoc.element.event-stream.merge">
        function <span class="apidocSignatureSpan">event-stream.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function () {
  var toMerge = [].slice.call(arguments)
  if (toMerge.length === 1 &amp;&amp; (toMerge[0] instanceof Array)) {
    toMerge = toMerge[0] //handle array as arguments object
  }
  var stream = new Stream()
  stream.setMaxListeners(0) // allow adding more than 11 streams
  var endCount = 0
  stream.writable = stream.readable = true

  if (toMerge.length) {
    toMerge.forEach(function (e) {
      e.pipe(stream, {end: false})
      var ended = false
      e.on('end', function () {
        if(ended) return
        ended = true
        endCount ++
        if(endCount == toMerge.length)
          stream.emit('end')
      })
    })
  } else {
    process.nextTick(function () {
      stream.emit('end')
    })
  }

  stream.write = function (data) {
    this.emit('data', data)
  }
  stream.destroy = function () {
    toMerge.forEach(function (e) {
      if(e.destroy) e.destroy()
    })
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&gt; concat â†’ merge

Merges streams into one and returns it.
Incoming data will be emitted as soon it comes into - no ordering will be applied (for example: `data1 data1 data2 data1 data2` -
where `data1` and `data2` is data from two streams).
Counts how many streams were passed to it and emits end only when all streams emitted end.

```js
es.<span class="apidocCodeKeywordSpan">merge</span>(
  process.stdout,
  process.stderr
).pipe(fs.createWriteStream('output.log'));
```

It can also take an Array of streams as input like this:
```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.parse" id="apidoc.element.event-stream.parse">
        function <span class="apidocSignatureSpan">event-stream.</span>parse
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (options) {
  var emitError = !!(options ? options.error : false)
  return es.through(function (data) {
    var obj
    try {
      if(data) //ignore empty lines
        obj = JSON.parse(data.toString())
    } catch (err) {
      if (emitError)
        return this.emit('error', err)
      return console.error(err, 'attempting to parse:', data)
    }
    //ignore lines that where only whitespace.
    if(obj !== undefined)
      this.emit('data', obj)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

}

//
// parse
//
// must be used after es.split() to ensure that each chunk represents a line
// source.pipe(es.split()).pipe(es.<span class="apidocCodeKeywordSpan">parse</span>())

es.parse = function (options) {
var emitError = !!(options ? options.error : false)
return es.through(function (data) {
  var obj
  try {
    if(data) //ignore empty lines
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.pause" id="apidoc.element.event-stream.pause">
        function <span class="apidocSignatureSpan">event-stream.</span>pause
        <span class="apidocSignatureSpan">(write, end, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function through(write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts &amp;&amp; opts.autoPause   === false)
  stream.autoDestroy = !(opts &amp;&amp; opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length &amp;&amp; !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable &amp;&amp; stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable &amp;&amp; stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

[node Stream documentation](http://nodejs.org/api/stream.html)

## through (write?, end?)

Re-emits data synchronously. Easy way to create synchronous through streams.
Pass in optional `write` and `end` methods. They will be called in the
context of the stream. Use `this.<span class="apidocCodeKeywordSpan">pause</span>()` and `this.resume()` to manage flow.
Check `this.paused` to see current flow state. (write always returns `!this.paused`)

this function is the basis for most of the synchronous streams in `event-stream`.

``` js

es.through(function write(data) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.pipe" id="apidoc.element.event-stream.pipe">
        function <span class="apidocSignatureSpan">event-stream.</span>pipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function () {

  var streams = [].slice.call(arguments)
    , first = streams[0]
    , last = streams[streams.length - 1]
    , thepipe = duplexer(first, last)

  if(streams.length == 1)
    return streams[0]
  else if (!streams.length)
    throw new Error('connect called with empty args')

  //pipe all the streams together

  function recurse (streams) {
    if(streams.length &lt; 2)
      return
    streams[0].pipe(streams[1])
    recurse(streams.slice(1))
  }

  recurse(streams)

  function onerror () {
    var args = [].slice.call(arguments)
    args.unshift('error')
    thepipe.emit.apply(thepipe, args)
  }

  //es.duplex already reemits the error from the first and last stream.
  //add a listener for the inner streams in the pipeline.
  for(var i = 1; i &lt; streams.length - 1; i ++)
    streams[i].on('error', onerror)

  return thepipe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var stream = new Stream()
stream.setMaxListeners(0) // allow adding more than 11 streams
var endCount = 0
stream.writable = stream.readable = true

if (toMerge.length) {
  toMerge.forEach(function (e) {
    e.<span class="apidocCodeKeywordSpan">pipe</span>(stream, {end: false})
    var ended = false
    e.on('end', function () {
      if(ended) return
      ended = true
      endCount ++
      if(endCount == toMerge.length)
        stream.emit('end')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.pipeable" id="apidoc.element.event-stream.pipeable">
        function <span class="apidocSignatureSpan">event-stream.</span>pipeable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipeable = function () {
  throw new Error('[EVENT-STREAM] es.pipeable is deprecated')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.pipeline" id="apidoc.element.event-stream.pipeline">
        function <span class="apidocSignatureSpan">event-stream.</span>pipeline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipeline = function () {

  var streams = [].slice.call(arguments)
    , first = streams[0]
    , last = streams[streams.length - 1]
    , thepipe = duplexer(first, last)

  if(streams.length == 1)
    return streams[0]
  else if (!streams.length)
    throw new Error('connect called with empty args')

  //pipe all the streams together

  function recurse (streams) {
    if(streams.length &lt; 2)
      return
    streams[0].pipe(streams[1])
    recurse(streams.slice(1))
  }

  recurse(streams)

  function onerror () {
    var args = [].slice.call(arguments)
    args.unshift('error')
    thepipe.emit.apply(thepipe, args)
  }

  //es.duplex already reemits the error from the first and last stream.
  //add a listener for the inner streams in the pipeline.
  for(var i = 1; i &lt; streams.length - 1; i ++)
    streams[i].on('error', onerror)

  return thepipe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// warn: just concatenates the string and then does str.split().join().
// probably not optimal.
// for smallish responses, who cares?
// I need this for shadow-npm so it's only relatively small json files.

es.replace = function (from, to) {
  return es.<span class="apidocCodeKeywordSpan">pipeline</span>(es.split(from), es.join(to))
}

//
// join chunks with a joiner. just like Array#join
// also accepts a callback that is passed the chunks appended together
// this is still supported for legacy reasons.
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.readArray" id="apidoc.element.event-stream.readArray">
        function <span class="apidocSignatureSpan">event-stream.</span>readArray
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArray = function (array) {
  var stream = new Stream()
    , i = 0
    , paused = false
    , ended = false

  stream.readable = true
  stream.writable = false

  if(!Array.isArray(array))
    throw new Error('event-stream.read expects an array')

  stream.resume = function () {
    if(ended) return
    paused = false
    var l = array.length
    while(i &lt; l &amp;&amp; !paused &amp;&amp; !ended) {
      stream.emit('data', array[i++])
    }
    if(i == l &amp;&amp; !ended)
      ended = true, stream.readable = false, stream.emit('end')
  }
  process.nextTick(stream.resume)
  stream.pause = function () {
     paused = true
  }
  stream.destroy = function () {
    ended = true
    stream.emit('close')
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Create a readable stream from an Array.

Just emit each item as a data event, respecting `pause` and `resume`.

``` js
  var es = require('event-stream')
    , reader = es.<span class="apidocCodeKeywordSpan">readArray</span>([1,2,3])

  reader.pipe(...)
```

If you want the stream behave like a 0.10 stream you will need to wrap it using [`Readable.wrap()`](http://nodejs.org/api/stream
.html#stream_readable_wrap_stream) function. Example:

``` js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.readable" id="apidoc.element.event-stream.readable">
        function <span class="apidocSignatureSpan">event-stream.</span>readable
        <span class="apidocSignatureSpan">(func, continueOnError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readable = function (func, continueOnError) {
  var stream = new Stream()
    , i = 0
    , paused = false
    , ended = false
    , reading = false

  stream.readable = true
  stream.writable = false

  if('function' !== typeof func)
    throw new Error('event-stream.readable expects async function')

  stream.on('end', function () { ended = true })

  function get (err, data) {

    if(err) {
      stream.emit('error', err)
      if(!continueOnError) stream.emit('end')
    } else if (arguments.length &gt; 1)
      stream.emit('data', data)

    immediately(function () {
      if(ended || paused || reading) return
      try {
        reading = true
        func.call(stream, i++, function () {
          reading = false
          get.apply(null, arguments)
        })
      } catch (err) {
        stream.emit('error', err)
      }
    })
  }
  stream.resume = function () {
    paused = false
    get()
  }
  process.nextTick(get)
  stream.pause = function () {
     paused = true
  }
  stream.destroy = function () {
    stream.emit('end')
    stream.emit('close')
    ended = true
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
create a readable stream (that respects pause) from an async function.
while the stream is not paused,
the function will be polled with `(count, callback)`,
and `this`  will be the readable stream.

``` js

es.<span class="apidocCodeKeywordSpan">readable</span>(function (count, callback) {
if(streamHasEnded)
  return this.emit('end')

//...

this.emit('data', data) //use this way to emit multiple chunks per call.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.replace" id="apidoc.element.event-stream.replace">
        function <span class="apidocSignatureSpan">event-stream.</span>replace
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (from, to) {
  return es.pipeline(es.split(from), es.join(to))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.split" id="apidoc.element.event-stream.split">
        function <span class="apidocSignatureSpan">event-stream.</span>split
        <span class="apidocSignatureSpan">(matcher, mapper, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function split(matcher, mapper, options) {
  var decoder = new Decoder()
  var soFar = ''
  var maxLength = options &amp;&amp; options.maxLength;
  if('function' === typeof matcher)
    mapper = matcher, matcher = null
  if (!matcher)
    matcher = /\r?\n/

  function emit(stream, piece) {
    if(mapper) {
      try {
        piece = mapper(piece)
      }
      catch (err) {
        return stream.emit('error', err)
      }
      if('undefined' !== typeof piece)
        stream.queue(piece)
    }
    else
      stream.queue(piece)
  }

  function next (stream, buffer) {
    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher)
    soFar = pieces.pop()

    if (maxLength &amp;&amp; soFar.length &gt; maxLength)
      stream.emit('error', new Error('maximum buffer reached'))

    for (var i = 0; i &lt; pieces.length; i++) {
      var piece = pieces[i]
      emit(stream, piece)
    }
  }

  return through(function (b) {
    next(this, decoder.write(b))
  },
  function () {
    if(decoder.end)
      next(this, decoder.end())
    if(soFar != null)
      emit(this, soFar)
    this.queue(null)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return es.duplex(child.stdin, child.stdout)

}

//
// parse
//
// must be used after es.<span class="apidocCodeKeywordSpan">split</span>() to ensure that each chunk represents a line
// source.pipe(es.split()).pipe(es.parse())

es.parse = function (options) {
var emitError = !!(options ? options.error : false)
return es.through(function (data) {
  var obj
  try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.stringify" id="apidoc.element.event-stream.stringify">
        function <span class="apidocSignatureSpan">event-stream.</span>stringify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function () {
  var Buffer = require('buffer').Buffer
  return es.mapSync(function (e){
    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + '\n'
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// stringify
//

es.stringify = function () {
  var Buffer = require('buffer').Buffer
  return es.mapSync(function (e){
    return JSON.<span class="apidocCodeKeywordSpan">stringify</span>(Buffer.isBuffer(e) ? e.toString() : e) + '\n'
  })
}

//
// replace a string within a stream.
//
// warn: just concatenates the string and then does str.split().join().
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.through" id="apidoc.element.event-stream.through">
        function <span class="apidocSignatureSpan">event-stream.</span>through
        <span class="apidocSignatureSpan">(write, end, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function through(write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts &amp;&amp; opts.autoPause   === false)
  stream.autoDestroy = !(opts &amp;&amp; opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length &amp;&amp; !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable &amp;&amp; stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable &amp;&amp; stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


//
// map sync
//

es.mapSync = function (sync) {
return es.<span class="apidocCodeKeywordSpan">through</span>(function write(data) {
  var mappedData
  try {
    mappedData = sync(data)
  } catch (err) {
    return this.emit('error', err)
  }
  if (mappedData !== undefined)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.wait" id="apidoc.element.event-stream.wait">
        function <span class="apidocSignatureSpan">event-stream.</span>wait
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wait = function (callback) {
  var arr = []
  return es.through(function (data) { arr.push(data) },
    function () {
      var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr)
        : arr.join('')
      this.emit('data', body)
      this.emit('end')
      if(callback) callback(null, body)
    })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// this is still supported for legacy reasons.
//

es.join = function (str) {

//legacy api
if('function' === typeof str)
  return es.<span class="apidocCodeKeywordSpan">wait</span>(str)

var first = true
return es.through(function (data) {
  if(!first)
    this.emit('data', str)
  first = false
  this.emit('data', data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.event-stream.writeArray" id="apidoc.element.event-stream.writeArray">
        function <span class="apidocSignatureSpan">event-stream.</span>writeArray
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArray = function (done) {
  if ('function' !== typeof done)
    throw new Error('function writeArray (done): done must be function')

  var a = new Stream ()
    , array = [], isDone = false
  a.write = function (l) {
    array.push(l)
  }
  a.end = function () {
    isDone = true
    done(null, array)
  }
  a.writable = true
  a.readable = false
  a.destroy = function () {
    a.writable = a.readable = false
    if(isDone) return
    done(new Error('destroyed before end'), array)
  }
  return a
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

create a writeable stream from a callback,
all `data` events are stored in an array, which is passed to the callback when the stream ends.

``` js
  var es = require('event-stream')
    , reader = es.readArray([1, 2, 3])
    , writer = es.<span class="apidocCodeKeywordSpan">writeArray</span>(function (err, array){
      //array deepEqual [1, 2, 3]
    })

  reader.pipe(writer)
```

## pause  ()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.event-stream.through" id="apidoc.module.event-stream.through">module event-stream.through</a></h1>


    <h2>
        <a href="#apidoc.element.event-stream.through.through" id="apidoc.element.event-stream.through.through">
        function <span class="apidocSignatureSpan">event-stream.</span>through
        <span class="apidocSignatureSpan">(write, end, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function through(write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts &amp;&amp; opts.autoPause   === false)
  stream.autoDestroy = !(opts &amp;&amp; opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length &amp;&amp; !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable &amp;&amp; stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable &amp;&amp; stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


//
// map sync
//

es.mapSync = function (sync) {
return es.<span class="apidocCodeKeywordSpan">through</span>(function write(data) {
  var mappedData
  try {
    mappedData = sync(data)
  } catch (err) {
    return this.emit('error', err)
  }
  if (mappedData !== undefined)
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>